import 'module-alias/register'
import { Association, CreationAttributes, Model, ModelStatic, ModelValidateOptions, StringDataType } from 'sequelize';

import { faker } from '@faker-js/faker';

const typemap = new Map<String, Function>([
	['INTEGER', () => faker.datatype.number()],
	['DECIMAL', () => faker.datatype.number()],
	['BIGINT', () => faker.datatype.number()],
	['STRING', (attr: { type: StringDataType }) => faker.datatype.string(attr.type.options?.length)],
	['TEXT', () => faker.datatype.string()],
	['DATETIME', () => faker.datatype.datetime()],
	['DATE', () => faker.datatype.datetime()],
	['JSONB', () => {}],
	['ENUM', (attr: { values: Array<String> }) => faker.helpers.arrayElement(attr.values)],
]);

const specializedTypemap = new Map<String, Function>([
	['isEmail', () => faker.internet.email()],
	['isIP', () => faker.internet.ip()],
	['isIPv4', () => faker.internet.ip()],
	['isIPv6', () => faker.internet.ipv6()],
	['isCreditCard', () => faker.finance.creditCardNumber('visa')],
]);

interface BuildOptions {
	fillOptional?: (boolean | Array<String>);
}

const trackedForDeletion: Array<Model<any,any>> = [];

function inferGeneratorFromValidators(validatorMap: ModelValidateOptions) {
	const enabledValidators = Object.entries(validatorMap)
		.filter(([validator, enabled]) => enabled === true)
		.map(([validator, enabled]) => validator)

	// just do naive inference; pick the first validator from the list
	return specializedTypemap.get(enabledValidators[0]);
}

export function overrideGenerator(type: String, generator: Function) {
    typemap.set(type, generator);
    specializedTypemap.set(type, generator);
}

export async function buildData<T extends Model<any, any>>(model: ModelStatic<T>, data: Record<string, any> = {}, options: BuildOptions = {}): Promise<any> {
	const fakeData: Record<string, any> = data;
	const associations: Record<string, Association> = Object.values(model.associations).reduce((associationMap, association) => {
		return { ...associationMap, [association.foreignKey]: association };
	}, {});
	const originatingSequelize = model.sequelize?.Sequelize;

	await Promise.all(Object.entries(model.rawAttributes).map(async ([attrName, attr]) => {
		const association = associations[attrName];
		// this ugly conditional simply says: if the field is optional, and we're getting
		// no requests that it should be filled, skip generating data; UNLESS, there's a full object
		// supplied under the association alias. There has to be a better way to untangle this ðŸ˜µ
		if (attr.allowNull === true && !(association && fakeData[association.as] !== undefined)) {
			if (options.fillOptional === undefined
				|| typeof options.fillOptional === "boolean" && options.fillOptional === false
				|| options.fillOptional instanceof Array && !options.fillOptional.includes(attrName)) {
				return;
			}
		}

		if(!attr.references) { // the attribute is NOT an association
			if (fakeData[attrName]) {
				return; // skip when data exists
			}

			if (attr.defaultValue !== undefined) {
				// god will not forgive us
				fakeData[attrName] = (originatingSequelize as any).Utils.toDefaultValue(attr.defaultValue);
				return;
			}

			// skip generating autoincrementing IDs and autogenerated fields (e.g. deletedAt)
			if (attr.autoIncrement || (attr as any)._autoGenerated === true) {
				return;
			}

			// generate fake data according to the field type
			// take the part before the length spec; e.g. VARCHAR from VARCHAR(255)
			const type = attr.type.constructor.name.split('(')[0];

			const generator = attr.validate ? inferGeneratorFromValidators(attr.validate) : typemap.get(type);
			if (generator === undefined) {
				if (type === 'VIRTUAL') {
					return;
				}
				throw new Error(`sequelize-bakery does not currently support ${type} ${attr.validate ? 'with validators ' + JSON.stringify(attr.validate) : '' }`);
			}

			if (typeof generator !== 'function') {
				throw new Error(`sequelize-bakery broke; ${type} builder is not a function`);
			}

			fakeData[attrName] = generator(attr);
		} else { // the attribute is an association
			if(typeof fakeData[attrName] === 'string' || typeof fakeData[attrName] === 'number') {
				const existingAssociatedInstance = await association.target.findByPk(fakeData[attrName]);
				fakeData[association.as] = existingAssociatedInstance;
			} else if(fakeData[association.as] instanceof (originatingSequelize as any).Model) { // association.as is the association name, so { User: { overrides } }
				fakeData[attrName] = fakeData[association.as].id;
			} else if(fakeData[association.as] !== undefined && fakeData[association.as] !== Object(fakeData[association.as])) {
				throw new Error(`You need to supply a Model, or an object for \`${model.name}.${association.as}\`.`);
			} else if (fakeData[attrName] === undefined) { // if it's not supplied, generate it
				const associatedModel = association.target;
				const instance = await build(associatedModel, fakeData[association.as], options);
				fakeData[association.as] = instance;
				fakeData[attrName] = instance.get('id');
			} else {
				throw new Error(`Cannot associate \`${model.name}.${association.as}\`.`);
			}
		}
	}));

	return fakeData as CreationAttributes<T>;
}

export async function build<T extends Model<any, any>>(model: ModelStatic<T>, data: Record<string, any> = {}, options: BuildOptions = {}): Promise<T> {
	const fakeData = await buildData(model, data, options);
	const instance: T = await model.create({ ...fakeData });
	trackedForDeletion.push(instance); // track the instance for deletion from DB
	Object.assign(instance, fakeData); // pre-load instances of the associations

	return instance;
}

export async function destroyAllBuilt() {
	for (const instance of trackedForDeletion.reverse()) {
		await instance.destroy({ force: true });
	}
}